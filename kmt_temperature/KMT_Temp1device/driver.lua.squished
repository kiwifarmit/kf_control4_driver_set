package.preload['SKC4.C4'] = (function (...)
-- Modulo che simula il modulo nativo di Control 4
-- in modo da poter testare codice destinato a Control4
-- su computer

if (C4) then
  return C4
else
  local C4 = {}
  
  C4.currentDir = ""
  
  function C4:FileSetDir(path)
     self.currentDir = path
  end
  
  function C4:FileExists(path)
     local fullPath = self._JoinPaths(self.currentDir, path)
     return (io.open(fullPath, "r") ~= nil)
  end
  
  function C4:FileGetSize(filePointer)
    local current = filePointer:seek()      -- get current position
    local size = filePointer:seek("end")    -- get file size
    filePointer:seek("set", current)        -- restore position
    return size
  end
  
  function C4:FileWrite(filePointer, len, stringData)
   return len, filePointer:write(stringData)
  end
  
  function C4:FileGetDir()
     return self.currentDir
  end
  
  function C4:FileOpen(path)
     local fullPath = self._JoinPaths(self.currentDir, path)
     local fs = io.open(fullPath, "a+")
     return fs or -1
  end
  
  function C4:FileSetPos(filePointer, filePosition)
    filePointer:seek('set',0)
    return filePointer:seek('set',filePosition)
  end
  
	function C4:FileClose(filePointer)
		io.close(filePointer)
  end
    
  function C4:FileDelete(path, joinFlag)
    local fullPath=path

    if (joinFlag ~= nil and joinFlag ~= false  ) then
      fullPath = self._JoinPaths(self.currentDir, path)
    end

    return (os.remove(fullPath) ~= nil)
  end
    
  function C4:_JoinPaths(first, second)
    local ret = nil
    
    if first and second then
        ret = string.format("%s/%s", first, second)
    else
        ret = first or second
    end
    
    return ret
  end
    
    return C4
end
 end)
package.preload['SKC4.Connections'] = (function (...)
local Connections = {}



function Connections.test () 
    return 2;
end


return Connections; end)
package.preload['SKC4.Control4Emu'] = (function (...)
require "SKC4"
 end)
package.preload['SKC4.Debug'] = (function (...)
local Debug = {}

Debug.DEBUGPRINT = true

function Debug.debug(message)
    if (Debug.DEBUGPRINT) then
        print(message);
	else
        message = ""
    end 
end

function Debug.tprint (tbl, indent)  --print table
	if type(tbl) == "table" then
		if not indent then indent = 0 end
		for k, v in pairs(tbl) do
			formatting = string.rep("   ", indent) .. k .. ": "
			if type(v) == "table" then
				print(formatting)
				Debug.tprint(v, indent+1)
			else

				print(formatting .. tostring(v, indent))
			end
		end
	else

		print (tbl)
	end
end

function Debug.tstring (tbl, indent) -- transform table in string, nested
	--ritorna una stringa contenente i valori della table
    --if indent is -1 return a table in one line string
	local  mytable = ""
	if not indent then indent = 0 end
	if (type(tbl) == "table") then
		if (indent == -1) then 
			for k,v in pairs(tbl) do
				mytable = mytable.." "..v
			end
		else

			for k, v in pairs(tbl) do
				formatting = string.rep("   ", indent) .. k .. ": "
				if type(v) == "table" then
					mytable = mytable .. formatting
					mytable = mytable ..Debug.tstring(v, indent+1)
				else

					mytable = mytable .. formatting .. tostring(v) .." \n"
				end
			end
		end
	else

		mytable = tbl
	end
	return mytable
end

return Debug; end)
package.preload['SKC4.LicenseManager'] = (function (...)
local TimerManager = require "SKC4.TimerManager"
--local Logger = require "SKC4.Logger"
--Logger:setLogLevel(LOG_LEVELS.DEBUG..LOG_LEVELS.ERROR)

local LicenseManager = {}

-- global var required by DriverCentral
DC_PID = 0 -- Product ID
DC_FD = false -- DriverCentral (Driver is not a free driver)
DC_FILENAME = "" -- "my_driver.c4z"

LicenseManager.TRIAL_NOT_STARTED = -1
LicenseManager.TRIAL_STARTED = 1
LicenseManager.TRIAL_EXPIRED = 0

function LicenseManager:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.currentVendorId = "DRIVERCENTRAL"
    self.statusMessage = ""
    self.vendorData = {
        DRIVERCENTRAL 	= { 
            ProductId 	= 000, -- Product ID
            FreeDriver 	= false, -- (Driver is not a free driver)
            FileName    = ""
        },
        HOUSELOGIX		= { 
            LicenseCode = "",
            ProductId 	= 000,
            ValidityCheckInterval = 60,
            --TrialExpiredLapse = 72,
            TrialExpiredLapse = 10,
            Licensed = false,
            Trial = LicenseManager.TRIAL_NOT_STARTED,  -- -1 not started, 1 started , 0 expired  -- only one possibility to stard it
            Version = ""
        }
    }

    self.houselogixTimerCheck = {}
    self.houselogixTimerTrial = {}
    return o
end

--
-- Setter and Getter
--

function LicenseManager:ON_PROPERTY_CHANGED_LicenseProvider(value)
	print("ON_PROPERTY_CHANGED.LicenseProvider.",value, type(value))
	--LicenseProvider = value
	LICENSE_MGR:setCurrentVendorIdByName(value)
end
function LicenseManager:ON_PROPERTY_CHANGED_HouselogixLicenseCode (value)
	--dbg("ON_PROPERTY_CHANGED.HouselogixLicenseCode."..value)
	HouselogixLicenseCode = value
    LICENSE_MGR:setParamValue("LicenseCode", HouselogixLicenseCode, "HOUSELOGIX") -- Filename -- DD394AB4A8CA48BB
    LICENSE_MGR:setParamValue("Licensed", false, "HOUSELOGIX")
    LICENSE_MGR:Houselogix_Activate()	
end



function LicenseManager:setStatusMessage( message )
    self.statusMessage = message
    C4:UpdateProperty ('Houselogix License Status', message)
end
function LicenseManager:getStatusMessage()
    return self.statusMessage
end

function LicenseManager:setCurrentVendorId(vendor_id)
    self.currentVendorId = vendor_id

    if vendor_id == "DRIVERCENTRAL" then
        print ("DRIVERCENTRAL vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 0)
        C4:SetPropertyAttribs("Automatic Updates", 1)
        C4:SetPropertyAttribs("Houselogix License Code", 1)
        C4:SetPropertyAttribs("Houselogix License Status", 1)
    elseif vendor_id == "HOUSELOGIX" then
        print ("HOUSELOGIX vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 1)
        C4:SetPropertyAttribs("Automatic Updates", 1)
        C4:SetPropertyAttribs("Houselogix License Code", 0)
        C4:SetPropertyAttribs("Houselogix License Status", 0)
    else
        print ("UNKNOW vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 1)
        C4:SetPropertyAttribs("Automatic Updates", 1)
        C4:SetPropertyAttribs("Houselogix License Code", 1)
        C4:SetPropertyAttribs("Houselogix License Status", 1)
    end
    
end
function LicenseManager:getCurrentVendorId()
    return self.currentVendorId
end

function LicenseManager:setCurrentVendorIdByName(value)
    if (value == "Driver Central") then
        self:setCurrentVendorId("DRIVERCENTRAL")
    elseif (value == "Houselogix") then
        self:setCurrentVendorId("HOUSELOGIX")
        self:trialTimerHandlerHouselogix()
    end
end
function LicenseManager:trialTimerHandlerHouselogix()
    local trialExpiredLapse = self:getParamValue("TrialExpiredLapse", "HOUSELOGIX") 
    if self:getParamValue("Trial", "HOUSELOGIX") == LicenseManager.TRIAL_NOT_STARTED then
        self:setParamValue("Trial", LicenseManager.TRIAL_STARTED, "HOUSELOGIX") 
        self.houselogixTimerTrial = TimerManager:new(trialExpiredLapse, "HOURS", self.onHouselogixTimerTrialExpire, false)
        self:setStatusMessage('Trial mode')
        self.houselogixTimerTrial:start()
    elseif self:getParamValue("Trial", "HOUSELOGIX") == LicenseManager.TRIAL_STARTED then
    elseif self:getParamValue("Trial", "HOUSELOGIX") == LicenseManager.TRIAL_EXPIRED then 
        self:Houselogix_Activate()
    else
        print ("Houeselogix Trial unknow state: "..(tostring(self:getParamValue("Trial", "HOUSELOGIX")) or "nil"))
    end
end

function LicenseManager:setParamValue(param_key, param_value, vendor_id)

    if (vendor_id) then
        --print("setParamValue with vendor_id")
        self.vendorData[vendor_id][param_key] = param_value
    else
        --print("setParamValue with automagic vendor_id")
        local autoVendorId = self:getCurrentVendorId()
        --print (autoVendorId)
        self.vendorData[autoVendorId][param_key] = param_value
    end
end
function LicenseManager:getParamValue(param_key, vendor_id)
    if (vendor_id) then
        return self.vendorData[vendor_id][param_key]
    else
        return self.vendorData[self:getCurrentVendorId()][param_key]
    end
end

--
-- Functions to test licence validity
--
function LicenseManager:isLicenseActive()
    if self:getCurrentVendorId() == "DRIVERCENTRAL" then
        return (DC.X == 1)
    elseif self:getCurrentVendorId() == "HOUSELOGIX" then
        return self:getParamValue("Licensed", "HOUSELOGIX")
    else
        return false
    end
end
function LicenseManager:isLicenseTrial()
    if self:getCurrentVendorId() == "DRIVERCENTRAL" then
        return (DC.X < 0)
    elseif self:getCurrentVendorId() == "HOUSELOGIX" then
        return self:getParamValue("Trial", "HOUSELOGIX")
    else
        return false
    end
end

function LicenseManager:isLicenseActiveOrTrial()
    return self:isLicenseActive() or self:isLicenseTrial()
end

function LicenseManager:isAbleToWork()
    local lic = self:isLicenseActive()
    local trial = self:isLicenseTrial() == 1 --this return 0,-1,1 and all this values are true in a if condition check
    return lic or trial
end

--
-- C4 Enviroment hooks
--

function LicenseManager:OnDriverInit()
    C4:SetPropertyAttribs("Cloud Status", 1)
    C4:SetPropertyAttribs("Automatic Updates", 1)
    C4:SetPropertyAttribs("Houselogix License Code", 1)
    C4:SetPropertyAttribs("Houselogix License Status", 1)
    
    self.vendorData = PersistData.vendorData or self.vendorData
    PersistData.vendorData = self.vendorData

    self:OnDriverInit_HouseLogix()
    self:OnDriverInit_DriverCentral()    
end

function LicenseManager:OnDriverLateInit()

    self:OnDriverLateInit_HouseLogix()    
    self:OnDriverLateInit_DriverCentral()    
end

--
-- Vendor specific functions
--
function LicenseManager:OnDriverInit_DriverCentral()
    require "json"
	JSON=(loadstring(json.JSON_LIBRARY_CHUNK))()
    -- set global vars required by DriverCentral.io
    DC_PID = self:getParamValue("ProductId", "DRIVERCENTRAL") 
	DC_FD = self:getParamValue("FreeDriver", "DRIVERCENTRAL") 
    DC_FILENAME = self:getParamValue("FileName", "DRIVERCENTRAL") 
    
    require "SKC4.licence.cloud_client_v1007"
end
function LicenseManager:OnDriverLateInit_DriverCentral()
    -- do something...
end

---------------
-- HouseLogix
---------------
function LicenseManager:OnDriverInit_HouseLogix()
    -- do something...
end
function LicenseManager:OnDriverLateInit_HouseLogix()   
    if self:getParamValue("Trial", "HOUSELOGIX") == LicenseManager.TRIAL_STARTED then
        local trialExpiredLapse = self:getParamValue("TrialExpiredLapse", "HOUSELOGIX") 
        self.houselogixTimerTrial = TimerManager:new(trialExpiredLapse, "HOURS", self.onHouselogixTimerTrialExpire, false)
        self.houselogixTimerTrial:start()
    end
end

function LicenseManager:onHouselogixTimerExpire(ticketId, sData, responseCode, tHeaders)
    
    if (LICENSE_MGR:getCurrentVendorId() == "HOUSELOGIX") then
        LICENSE_MGR:Houselogix_Activate()	
    end
end

function LicenseManager:onHouselogixTimerTrialExpire(ticketId, sData, responseCode, tHeaders)
    print ("Houselogix Trial timer Expired!")
    LICENSE_MGR:setParamValue("Trial", LicenseManager.TRIAL_EXPIRED, "HOUSELOGIX") 
    if (LICENSE_MGR:getCurrentVendorId() == "HOUSELOGIX") then
        LICENSE_MGR:setParamValue("Licensed", false, "HOUSELOGIX")
        LICENSE_MGR:Houselogix_Activate()	
    end
end



--- -----------------------------------------------------------------
--- HOUSELOGIX LICENSE_MGR MANAGER
--- -----------------------------------------------------------------


function LicenseManager:Houselogix_Activate()
  self:setStatusMessage('Activating driver license...')
  mac = C4:GetUniqueMAC ()

  local license_code = self:getParamValue("LicenseCode", "HOUSELOGIX")
  local Houselogix_product_number = self:getParamValue("ProductId", "HOUSELOGIX")
  local sw_version = self:getParamValue("Version", "HOUSELOGIX")
  local postData = string.format('lic=%s&mac=%s&p=%s&ver=%s', license_code, mac, Houselogix_product_number, sw_version)
  --dbg (postData)
  ticketId = C4:urlPost('https://www.houselogix.com/license-manager/activatelicense.asp', postData, {}, false, self.Houselogix_Response)
  --methodType[ticketId] = "HLicense_Activate" -- QUESTA SERVE ANCORA? TOFIX
end

function LicenseManager.Houselogix_Response(ticketId, data, responseCode, tHeaders, strError )
  print('OnLicenseActivationResponseReceived')
  --dbg(ticketId)
  --dbg(data)
  local i = string.find(data, 'Valid')
  if (i) then
    LICENSE_MGR:setParamValue("Licensed", true, "HOUSELOGIX")
    LICENSE_MGR:setStatusMessage('Activated (last checked on: '..os.date("%m/%d/%Y %X")..')')
  elseif (string.find(data, 'Unauthorized')) then
    LICENSE_MGR:setParamValue("Licensed", false, "HOUSELOGIX")
    LICENSE_MGR:setStatusMessage('Invalid license key')
    --LICENSE_MGR.houselogixTimerCheck = TimerManager:new(60, "MINUTES", LICENSE_MGR.onHouselogixTimerExpire, false)
    --LICENSE_MGR.houselogixTimerCheck:start()
    print("License is NOT ok")
  elseif (string.find(data, 'Failed')) then
    if LICENSE_MGR:getParamValue("Licensed", "HOUSELOGIX") then 
        LICENSE_MGR:setParamValue("Licensed", true, "HOUSELOGIX")
    else
        LICENSE_MGR:setParamValue("Licensed", false, "HOUSELOGIX")
    end
    LICENSE_MGR:setStatusMessage('Failed to verify')
    --LICENSE_MGR.houselogixTimerCheck = TimerManager:new(60, "MINUTES", LICENSE_MGR.onHouselogixTimerExpire, false)
    --LICENSE_MGR.houselogixTimerCheck:start()
  else
   -- LICENSE_MGR:setParamValue("Licensed", false, "HOUSELOGIX")
    LICENSE_MGR:setStatusMessage(strError)
    
  end
  local checkInterval =  LICENSE_MGR:getParamValue("ValidityCheckInterval", "HOUSELOGIX") 
  LICENSE_MGR.houselogixTimerCheck = TimerManager:new(checkInterval, "MINUTES", LICENSE_MGR.onHouselogixTimerExpire, false)
  LICENSE_MGR.houselogixTimerCheck:start()
  --return HLicense
end


-- return LicenseManager

LICENSE_MGR = LICENSE_MGR or LicenseManager:new()

 end)
package.preload['SKC4.Logger'] = (function (...)
-- Modulo per gestire i file di log

local Logger = {}

ut = require "SKC4/Utility"
--local C4 = require("SKC4/C4")

function Logger:new (o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.logLevels = {
      ["INFO"] = "I",
      ["WARN"] = "W",
      ["ERROR"] = "E",
      ["FATAL"] = "F",
      ["DEBUG"] = "D",
      ["NONE"] = "-",
      ["ALL"]  = "IWEFD",
      }
    self._DEFAULT_OUTPUT_FORMAT     = "%s %s:%s -- %s\n"
    self._DEFAULT_FILE_NAME_FORMAT  = "%s_%s.log"    
    self._DEFAULT_DATE_FORMAT       = "%Y%m%d%H%M%S"

    self._DEFAULT_FILE_POINTER      = io.stdio
    self._DEFAULT_FILE_NAME         = nil
    self._DEFAULT_FILE_PATH         = nil 
    self._DEFAULT_MAX_FILES         = 0
    
    self._currentMaxNumberOfFIles        = self._DEFAULT_MAX_FILES
    self._currentFilePointer        = self._DEFAULT_FILE_POINTER
    self._currentFilePath           = self._DEFAULT_FILE_PATH
    self._currentFileName           = self._DEFAULT_FILE_NAME
    self._currentLogLevel           = self.logLevels.INFO
    self._currentOutputFormat       = self._DEFAULT_OUTPUT_FORMAT
    self._currentFileNameFormat     = self._DEFAULT_FILE_NAME_FORMAT
    self._currentLogMaxSize         = 2097152 -- 2MB
    return o
end

function Logger:findLevelKey(level)
  for k,v in pairs(self.logLevels) do
    if (v == level) then
      return k
    end
  end
  return nil
end

function Logger:write(message)
    self:rotate()    
    if (self._currentFilePointer ~= nil and self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
        C4:FileWrite(self._currentFilePointer,message:len(), message)
    else
        print(message)    --because C4 do not open by default the io.stdio like file_pointer 
	end    
    return message
end

--function Logger:formattedWrite(level, source, message)
function Logger:formattedWrite(...)
    --local fullLevel = self:findLevelKey(level)
    --local outString = string.format(self._currentOutputFormat,
    --    fullLevel,
    --    os.date("%m/%d/%Y %H:%M:%S"),
    --    source,
    --    message)
    local level,source,message
    if ... then
		level = select(1, ...)
		source = select(2, ...)
		message = select(3, ...)
    end
    local fullLevel = self:findLevelKey(level)
    local info = debug.getinfo(3,'lS');

    local message = ""

    -- convert all params into strings
    for key,val in ipairs(...) do
        if (message.length == 0) then
            message = self:convertToString(val)
        else
            message = message .." "..self:convertToString(val)
        end
    end
    
    local outString = string.format(self.currentOutputFormat,
        fullLevel,
        info.source,
        info.currentline,
        message)
    return self:write(outString)
end

function Logger:convertToString(obj)
    local encoded = json.encode( obj, { indent=true } )

    if (type(obj) == "table") then
    if not encoded then
        -- LOGGER:debug( "Table encoding failed")
        return tostring(obj)
    else
        -- LOGGER:debug( "Table successfully encoded!" )
        return encoded
    end
    else
        return tostring(obj)
    end
end

function Logger:setLogLevel(level)
  local flag = true
  
  for x in level:gfind(".") do
    key = self:findLevelKey(x)
    self._currentLogLevel = self.logLevels.NONE;
    if (self.logLevels[key] == nil) then flag = false; break; end
  end
  if ( flag == true ) then
      self._currentLogLevel = level
  end

end

function Logger:getLogLevel(level)
    return self._currentLogLevel;
end

function Logger:isLogLevelEnabled(level)
  return (self._currentLogLevel:find(level) ~= nil) 
end


function Logger:open(filePath, fileName)
  self._currentFilePath = filePath
  self._currentFileName = fileName 
  
  C4:FileSetDir(self._currentFilePath)  --move in file path folder

  logFileName = string.format(self._currentFileNameFormat, fileName, os.date(self._DEFAULT_DATE_FORMAT));
  -- Open the file
  self._currentFilePointer = C4:FileOpen(logFileName)
  local pos = C4:FileGetSize(self._currentFilePointer)
  C4:FileSetPos(self._currentFilePointer, pos)

  C4:FileSetDir('/')
  return self._currentFilePointer, logFileName
end

function Logger:close()
    -- only if a file is open
  if (self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
    
    -- Close the file
    if (self._currentFilePointer ~= nil) then
        C4:FileClose(self._currentFilePointer)
        --self._currentFilePointer:close()
        self._currentFilePointer = self._DEFAULT_FILE_POINTER
        self._currentFilePath = nil
        self._currentFileName = nil
    end
  end
end

function Logger:info(source, message)
    if (self:isLogLevelEnabled(self.logLevels.INFO)) then
        return self:formattedWrite(self.logLevels.INFO, source, message);
    end 
end

function Logger:warn(source, message)
    if (self:isLogLevelEnabled(self.logLevels.WARN)) then
        return self:formattedWrite(self.logLevels.WARN, source, message);
    end 
end

function Logger:error(source, message)
    if (self:isLogLevelEnabled(self.logLevels.ERROR)) then
        return self:formattedWrite(self.logLevels.ERROR, source, message);
    end 
end

function Logger:fatal(source, message)
    if (self:isLogLevelEnabled(self.logLevels.FATAL)) then
        return self:formattedWrite(self.logLevels.FATAL, source, message);
    end 
end

function Logger:debug(source, message)
    if (self:isLogLevelEnabled(self.logLevels.DEBUG)) then
        return self:formattedWrite(self.logLevels.DEBUG, source, message);
    end 
end

function Logger:setMaxLogSize( size )
  self._currentLogMaxSize = size
end

function Logger:setMaxLoggersNumber( number )
    self._currentMaxNumberOfFIles = number
  end

function Logger:getMaxLogSize()
  return self._currentLogMaxSize
end

function Logger:getFilePointer()
    return self._currentFilePointer
end

function Logger:getFilePath()
    return self._currentFilePath
end

function Logger:getFileName()
    return self._currentFileName
end

function Logger:rotate(force)
    if (self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
        local fileSize = C4:FileGetSize(self._currentFilePointer)
        
        if (self._currentMaxNumberOfFIles ~= self._DEFAULT_MAX_FILES) then 
            local loggersNumber = self:getLoggersNumber()
            print ("loggersNumber", loggersNumber)
            while (loggersNumber >= self._currentMaxNumberOfFIles) do
                print ("loggersNumber >= self._currentMaxNumberOfFIles",loggersNumber >= self._currentMaxNumberOfFIles)
                self:removeFirst()
                loggersNumber = self:getLoggersNumber()
            end
        end
        if (force ~= nil or tonumber(fileSize) > self._currentLogMaxSize) then
            local oldPath = self._currentFilePath -- store old value 'cause close() clear _currentFilePath
            local oldName = self._currentFileName -- store old value 'cause close() clear _currentFileName
            self:close() 
            return self:open(oldPath,oldName)
        else
            return self._currentFilePointer, self._currentFilePath, self._currentFileName
        end
    end
end

--private
function Logger:getLoggersNumber()    
    C4:FileSetDir(self._currentFilePath)
    local loggerList = C4:FileList()
    local count = 0
    for k,v in pairs(loggerList) do
        ----print (k,v) 
        if (string.match(v, self._currentFileName)) then 
            ----print (string.match(v, self._currentFileName))
            count = count + 1 
        end
    end
    C4:FileSetDir("/")
    return count 
end

function Logger:removeFirst()    
    C4:FileSetDir(self._currentFilePath)
    local loggerList = C4:FileList()
    local count = 0
    ----------------20171204114408
    local minimum = 30000000000000
    local fileToRemove = ""
    for k,v in pairs(loggerList) do 
        if (string.match(v, self._currentFileName)) then 
            ----print (string.match(v, self._currentFileName))
            local n = tonumber(string.match (v, "(%d+)"))
            ----print ("n:  ", n)
            ----print ("file:  ", v)
            if ( n < minimum ) then 
                minimum = n
                fileToRemove = v 
            end
        end
    end

    ----print (fileToRemove, minimum)
    if (fileToRemove ~= "") then  
        print("deleting logger :",fileToRemove)
        C4:FileDelete(fileToRemove) 
    end
    C4:FileSetDir("/")
    return count 
end


return Logger;

 end)
package.preload['SKC4.SKC4'] = (function (...)
local SKC4 = {}

SKC4.version = "0.0.1"
-- SKC4.Connections = require("SKC4.Connections");
SKC4.Logger = require("SKC4.Logger");
-- SKC4.Debug = require("SKC4.Debug"); -- Alias per un logger che scrive su stdout
SKC4.Utility = require("SKC4.Utility"); -- Alias per un logger che scrive su stdout
SKC4.TimerManager = require("SKC4.TimerManager")
SKC4.LicenceManager = require("SKC4.LicenseManager")
return SKC4;
 end)
package.preload['SKC4.TimerManager'] = (function (...)
--C4 = require 'SKC4.C4' -- if we are not in C4 env, I'll emulate it
local TimerManager = {}


function TimerManager:new (interval_delay, time_unit, on_expire_callback, will_repeat, o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self

    self.interval_delay = interval_delay
    self.callback = on_expire_callback
    self.will_repeat = will_repeat
    self.timerId = 0 
    -- , SECONDS, MINUTES and HOURS
    if (time_unit == "SECONDS") then
        self.time_unit = 1000
    elseif (time_unit == "MINUTES") then
        self.time_unit = 60*1000
    elseif (time_unit == "HOURS") then
        self.time_unit = 60*60*1000
    else
        self.time_unit = 1
    end 
    return o
end

function TimerManager:start()
    if (self.timerId) then
        self:stop()
    end
    self.timerId = C4:SetTimer(self.interval_delay * self.time_unit, self.callback, self.will_repeat)
end

function TimerManager:stop()
    self.timerId = C4:KillTimer(self.timerId)
end

--
-- Setter and Getter
--


--
-- Private functions
--


return TimerManager
 end)
package.preload['SKC4.Utility'] = (function (...)
local Utility = {}


--remove the first element of a list
function Utility.remove(tbl, index)
	if (index == nil ) then index = 1 end
	local a = {}
	--local b = {}
	--local c
	for n,v in pairs(tbl) do 
		table.insert(a, n) 
	end
	table.sort(a)
	local f = nil
	local o = {}
	for i, t in pairs(a) do
		if (f == nil) then 
			f = tbl[t]
		else
			table.insert(o, tbl[t])
		end
	end
	 --Utility.tprint(b)
	return o, f
end

function Utility.tprint (tbl, indent)  --print table
	if type(tbl) == "table" then
		if not indent then indent = 0 end
		for k, v in pairs(tbl) do
			formatting = string.rep("   ", indent) .. k .. ": "
			if type(v) == "table" then
				print(formatting)
				Utility.tprint(v, indent+1)
			else
				print(formatting .. tostring(v, indent))
			end
		end
	else
		print (tbl)
	end
end

function Utility.tstring (tbl, indent) -- transform table in string, nested
	--ritorna una stringa contenente i valori della table
    --if indent is -1 return a table in one line string
	local  mytable = ""
	if indent == nil then indent = 0 end
	if (type(tbl) == "table") then
		if (indent == -1) then 
			for k,v in pairs(tbl) do
				if type(v) == "table" then
					mytable = mytable .. " "..Utility.tstring(v, -1)
				else
					mytable = mytable ..k.. " " .. tostring(v) 
				end
			end
		elseif(type(indent) == "number") then
			for k, v in pairs(tbl) do
				formatting = string.rep("   ", indent) .. k .. " : "
				if type(v) == "table" then
					mytable = mytable .. "\n"..formatting
					mytable = mytable .."\n"..Utility.tstring(v, indent+1)
				else
					mytable = mytable .. formatting .. tostring(v) .." \n"
				end
			end
		elseif(type(indent) == "string") then
			for k, v in pairs(tbl) do
				--formatting = string.rep("   ", indent) .. k .. " : "
				if type(v) == "table" then
					formatting = indent .. k
					mytable = mytable .. formatting
					mytable = mytable .. Utility.tstring(v, indent)
				else
					mytable = mytable ..indent .. tostring(v)
				end
				
			end
			mytable = mytable .."\n"
		end
	else 
		mytable = tbl
	end
	return mytable
end



--get the "very" first element of a Table... let's lua, not only if is key is a number like getn
function Utility.getFirstId(T)
	if (T == nil) then
		return {}
	else  
		local n  = 1
		local f
		for k, v in pairs(T) do
			if n == 1 then f = k end
		end
		return f
	end
end

function Utility.tableLength(T)
	local count = 0
	for _ in pairs(T) do count = count + 1 end
	return count
  end

--take "str" (string) and slpit it by "inSplitPattern" returning a table of the substring splitted in "outResults"(optional)
function Utility.split(str, inSplitPattern, outResults ) 
    if not outResults then
		outResults = {}
	end
	local theStart = 1
	local theSplitStart, theSplitEnd = string.find( str, inSplitPattern, theStart )
	while theSplitStart do
		table.insert( outResults, string.sub( str, theStart, theSplitStart-1 ) )
		theStart = theSplitEnd + 1
		theSplitStart, theSplitEnd = string.find( str, inSplitPattern, theStart )
	end
	table.insert( outResults, string.sub( str, theStart ) )
	return outResults
end


function Utility.Avg_DevStd(value, stddev, avg, n)
    local delta = value - avg
    n = n+1
    avg = avg + delta / n 
    stddev = math.sqrt(((stddev*stddev * (n-1)) + delta*(value - avg))/n)
    return stddev, avg, n 
end

-- Private members
function pairsByKeys (t, f)
	local a = {}
	for n in pairs(t) do table.insert(a, n) end
	table.sort(a, f)
	local i = 0      -- iterator variable
	local iter = function ()   -- iterator function
	  i = i + 1
	  if a[i] == nil then return nil
	  else return a[i], t[a[i]]
	  end
	end
	return iter
end



return Utility



 end)
package.preload['SKC4.licence.cloud_client_v1007'] = (function (...)
-- Please put here the cloud client code as provided by DriverCentral.
return {} end)
-- KMT Temperature Devices HOUSELOGIX 1 DEVICE BOARD
-- variabili da settare 
max_license_val = 200 --molto alto è difficile che possa succedere
unique_device_id = "Max KMT Temperature Devices"

-- tables and variables
--- Build License Manager object
require 'SKC4.LicenseManager'
require 'SKC4.Utility'
--- Config License Manager
LICENSE_MGR:setParamValue("ProductId", XXX , "DRIVERCENTRAL") -- Product ID
LICENSE_MGR:setParamValue("FreeDriver", false, "DRIVERCENTRAL") -- (Driver is not a free driver)
LICENSE_MGR:setParamValue("FileName", "KMTronic_1_temperature_sensor.c4z", "DRIVERCENTRAL") -- Filename
LICENSE_MGR:setParamValue("ProductId", XXX, "HOUSELOGIX") -- Filename
LICENSE_MGR:setParamValue("LicenseCode", "Put here your licence", "HOUSELOGIX") -- Filename -- DD394AB4A8CA48BB
LICENSE_MGR:setParamValue("Version", C4:GetDriverConfigInfo ("version"), "HOUSELOGIX") -- Filename -- DD394AB4A8CA48BB
LICENSE_MGR:setParamValue("Trial", LICENSE_MGR.TRIAL_NOT_STARTED, "HOUSELOGIX") -- Filename -- DD394AB4A8CA48BB
--------------------------------------------
-- REMOVE THIS TO ENABLE LICENCE MANAGEMENT 
LICENSE_MGR:isLicenseActive = function ()
    return true
end
LICENSE_MGR:isLicenseTrial = function ()
    return 1
end
--------------------------------------------

EX_CMD = {}
PRX_CMD = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}

KMT_IP = "KMTronic IP"
KMT_Port = "KMTronic Port"
KMT_User = "KMTronic User"
KMT_Pwd = "KMTronic Password"
Debug = "Debug"
Polling = "Polling"
Polling_sec = "Polling minutes"
dealer_email = "Dealer e-mail"
License_Provider = "License Provider"
HL_Licence_code = "Houselogix License Code"
license_count = 0
max_device = 1 --fixme da gestire
too_many = false


-- Temperature Status Table
ReadTemp = {}

    -- all initial temps is 0
    for x = 1,4 do 
	   ReadTemp[x] = {}
	   ReadTemp[x].temp = 0
	   ReadTemp[x].name = ""
    end



-- inizializzo variabili
for x = 1, 4 do
    C4:DeleteVariable("Temp_value_"..x)
    C4:AddVariable("Temp_value_"..x, 0, "NUMBER",true)
end



---------------------------------------------------------------------
-- Table of function from common
---------------------------------------------------------------------
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_UPDATE = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}

-- cambio di una variabile
function OnVariableChanged(strName)

    Dbg("OnVariableChanged")

end

function OnPropertyChanged(sProperty)
    Dbg("OnPropertyChanged")
    -- Polling
	if poll_timer~= nil then poll_timer = C4:KillTimer(poll_timer) end
	poll_timer = StartPollTimer()

	local value = Properties[sProperty]
	if (sProperty == License_Provider) then
		--verifico numero di device
		too_many = false
		driver_installed = checkDeviceInstalled()
		--print(driver_installed)
		if driver_installed > max_device then
			license_txt = "Too many device buy unlimited driver for more"
			too_many = true
			print(license_txt)
		else
			Dbg("strProperty == 'License_Provider'") 
			LICENSE_MGR:ON_PROPERTY_CHANGED_LicenseProvider(value)
		end
	end
	if (sProperty == HL_Licence_code) then 
		Dbg("strProperty == 'HL_Licence_code'")
		LICENSE_MGR:ON_PROPERTY_CHANGED_HouselogixLicenseCode(value)
	end
    
    if string.find(sProperty,"Calibrate") ~= nil then
	   updateKmtStatus()
    end
    
end

function StartPollTimer()

	   if DelayPolling > 0  then
    		  id = C4:AddTimer(tonumber(DelayPolling), "MINUTES", true)
		  Dbg("Start Polling Timer with "..DelayPolling.. " minutes of frequency")
	   else
		  id = C4:AddTimer(tonumber(Properties[Polling_sec]), "MINUTES", true)
		  --print(id)
		  Dbg("Start Polling Timer with "..Properties[Polling_sec].. " minutes of frequency")

	   end
	   return id
end



---------------------------------------------------------------------
-- Initialization/Destructor Code
---------------------------------------------------------------------
function checkDeviceInstalled()
    -- restituisce il numero dei driver presenti nel progetto
    --print(C4:GetProjectItems())
	   string_find = unique_device_id
      x, driver_installed = string.gsub(C4:GetProjectItems(), string_find, string_find)
	 --driver_installed = driver_installed/2 -- la funzione precedente restituisce 2 per ogni driver
	 print("Number of driver installed: ".. driver_installed)
    return driver_installed
end
--[[function HLicense_Activate()
  C4:UpdateProperty(License_status, 'Activating driver license...')
  mac = C4:GetUniqueMAC ()

  local postData = string.format('lic=%s&mac=%s&p=%s&ver=%s', Properties[License_code], mac, product_number, sw_version)
  urlPost('https://www.houselogix.com/license-manager/activatelicense.asp', postData, {}, function(strData) HLicense_Response(strData) end)
end

function HLicense_Response(data)
  Dbg('OnLicenseActivationResponseReceived')
  local i = string.find(data, 'Valid')
  if too_many == false then
	 if (i) then
		    C4:UpdateProperty(License_status, 'Activated (last checked on: '..os.date("%m/%d/%Y %X")..')')
		    
		    Licenziato = true
		    license_count = 0
		    
	 elseif (string.find(data, 'Unauthorized')) then
			Licenziato = false
			C4:UpdateProperty('License Status', 'Invalid license key')
			license_count = 0
			print("License is NOT ok")
	 end
    end
  --return HLicense
end


function checkLicense()
	--print(Licenziato)
    if (Licenziato == true)  then
	   --Properties[License_status] = "Licensed"
	   Licenziato = true
	   license_count = license_count + 1
    else
		  HLicense_Activate()
	end
	if (license_count > max_license_val) then
		HLicense_Activate() --ricontrollo licenza ogni max_license_val
	end

    --print(tostring(Licenziato)..license_count)
    return Licenziato
end]]

function OnDriverInit()
    print('Driver KMT Init')
    --print(poll_timer)
    --Licenziato = checkLicense()
	--local t = C4:SetTimer(5000, function(timer) HLicense_Activate() print("License testing...") end) 
	LICENSE_MGR:OnDriverInit()  

end

function OnDriverLateInit()
    print('Driver KMT LateInit')
    --g_cnt = 0
    DelayPolling = 0
    -- avvio timer con ritardo (5 sec) altrimenti non funzione
	PollTimerRestart ()
	LICENSE_MGR:OnDriverLateInit() 

end


function OnDriverUpdate()
    -- distruggo il timer
    poll_timer = C4:KillTimer(poll_timer)
end

function OnDriverDestroyed()
    -- distruggo il timer
    poll_timer = C4:KillTimer(poll_timer)
end

-- Timer Expire
function OnTimerExpired(idTimer)
    -- controllo licenza
    if LICENSE_MGR:isAbleToWork() then
		if (idTimer == poll_timer) then
		   Dbg("Timer fired ")
		   updateKmtStatus()
		   --printStatus = true
		else
		   C4:KillTimer(idTimer)
		   poll_timer = 0
		end
	end
end

----------------------------------------- 
--Connection Functions 
-----------------------------------------

function OnBindingChanged(idBinding, class, bIsBound)
    Dbg("OnBindingChanged")
    updateKmtStatus()
end


function KmtCreateUrl()
    IP = Properties[KMT_IP]
    Port = Properties[KMT_Port]
    User = Properties[KMT_User]
    Pwd = Properties[KMT_Pwd]
    KmtUrl = 'http://'..User..':'..Pwd..'@'..IP..':'..Port
    return KmtUrl
end


function PollTimerRestart () 
    C4:SetTimer(5000, function(timer)
				poll_timer = StartPollTimer()
			 end)
end



function LUA_ACTION.DisplayStatus()
	Dbg("Display Temperature Status")
	updateKmtStatus()
    printStatus = true

end

function DbgStatus()
    tempstatus = " Temperature sensors Status\n"
    for x = 1,4 do 
	   tempstatus = tempstatus..ReadTemp[x].name.." > " ..ReadTemp[x].temp 
	   tempstatus = tempstatus.." °C (with correction(calibration) of: "..leggiPropCal(x).." \n"
    end
    Dbg(tempstatus)
end

function ReadKmtStatus()

		--local z = 4
		-- reset
		for x = 1,4 do 
			ReadTemp[x].temp = 0
			ReadTemp[x].name = x.." - not installed"
		end

		for x, y in pairs(KmtStatus) do
			
		    if string.find(x, 'sensor') ~= nil then
			  if y.temp ~= "---" then
				-- 
				a = x:gsub( 'sensor', '')
				tempNum = CommaOrPoint(y.temp)
				z = tonumber(a)

				ReadTemp[z].temp = SetTemp(z,tempNum) 
				ReadTemp[z].name = z.." - "..y.name
				C4:SetVariable("Temp_value_"..z,ReadTemp[z].temp)
				tt = tonumber(ReadTemp[z].temp)
				ttString = tostring(ReadTemp[z].temp)
				
				C4:SendToProxy(z,"TEMPERATURE_CHANGED",  {TEMPERATURE = ttString}, "NOTIFY")
				C4:SendToProxy(4+z,"TEMPERATURE_CHANGED",  {TEMPERATURE = tt, SCALE = "CELSIUS"}, "COMMAND")
			  end
			  --z = z-1
			  
		    end
		end
		if printStatus then
		   DbgStatus()
		   printStatus = false
		end
end

function round(num, idp)
  return tonumber_loc(string.format("%." .. (idp or 0) .. "f", num))
end
function tonumber_loc(str, base)
	if (type(str)=="string") then
	  local s = str:gsub(",", ".") -- Assume US Locale decimal separator
	  local num = tonumber(s, base)
	  if (num == nil) then
		s = str:gsub("%.", ",") -- Non-US Locale decimal separator
		num = tonumber(s, base)
	  end
	  return num
	else
	  return tonumber(str)
	end	
end
-- parsing XML per stato relay
function updateKmtStatus()
    KmtUrl = KmtCreateUrl()
    url = KmtUrl..'/status.xml'
    C4:urlGet(string.format(url),{}, false,
				function(ticketId, strData, responseCode, tHeaders, strError)
				    if (strError == nil) then
        				KmtStatus = parseKmtStatus(strData)
						ReadKmtStatus()
						if DelayPolling > 0 then
						   DelayPolling = 0
						   poll_timer = C4:KillTimer(poll_timer)
						   poll_timer = StartPollTimer()
						end
				    else
					   	--Dbg("Connection error with: "..Properties[KMT_IP].. " - " ..strError)
						if DelayPolling < 300 then
							 DelayPolling =  DelayPolling + 10
						else
							DelayPolling = 310
							Dbg("Connection error with: "..Properties[KMT_IP].. " - Delay poll at 5 mins - "..strError)
							poll_timer = C4:KillTimer(poll_timer)
							poll_timer = StartPollTimer()
						end
						  
				    end
				end
  )
end

function _subTableTree(node)
    local hash = {}
    for k,childNode in pairs(node['ChildNodes']) do -- ciclo sui figli 
	   if childNode['Name'] == "sensor" then
		  childNode['Name'] = childNode['Name']..k
		  --print(childNode['Name'])
	   end
        if (childNode['ChildNodes']) then
            hash[childNode['Name']] = _subTableTree(childNode)
            if (childNode['Value'] and childNode['Value'] ~= "") then
                hash[childNode['Name']] = childNode['Value']
			 --print("Name = " ..childNode['Name'].." - Value = " ..childNode['Value'])
            end
        end
    end
    return hash
end

function parseKmtStatus(xmlString)
    rootNode = C4:ParseXml(xmlString)
    result = _subTableTree(rootNode)
    return result
end


function ReceivedFromProxy(idBinding, sCommand, tParams)
	if (sCommand ~= nil) then
		if(tParams == nil)		-- initial table variable if nil
			then tParams = {}
		end

		if (PRX_CMD[sCommand]) ~= nil then
			PRX_CMD[sCommand](idBinding, tParams)
		else
			Dbg("ReceivedFromProxy: Unhandled command = " .. sCommand)
		end
	end
end

-- Calibrazione
function SetTemp(nrSensor,strValue)
    CalValue=GetCalibration(nrSensor)
    --strValue = string.gsub(strValue,"%.",",")
    readTemp =  round(tonumber(strValue),2)
    tempFloat = readTemp + CalValue
    temp =  round(tempFloat,0)
    --print(temp)
    return temp
end

function CommaOrPoint(strNumber)
    lessPoint = string.gsub(strNumber,"%.","")
    num = tonumber(lessPoint)/100
    return num
end

function GetCalibration(nrSensor)
    cal = leggiPropCal(nrSensor)
    cal = string.gsub(cal,',','.') -- sostituisco la virgola con il punto
    isNum = tonumber (cal)
    if isNum == nil then
	   isNum = 0
	   Dbg("Calibration "..nrSensor.." properties in not a number.So I set it to value=0")
    end
    --print(cal, isNum)
    return isNum
end

function leggiPropCal(nrSensor)
    Cal = {}
    Cal[1] = Properties["Calibrate Sensor 1"]
    Cal[2] = Properties["Calibrate Sensor 2"]
    Cal[3] = Properties["Calibrate Sensor 3"]
    Cal[4] = Properties["Calibrate Sensor 4"]
    return Cal[nrSensor]
end

-----------------------------------------
-- Common URL function
-----------------------------------------

g_responseTickets = {}

function ReceivedAsync(ticketId, strData, responseCode, tHeaders, strError)
	local ticket = pullUrlTicket(ticketId)
	if (not ticket) then dbg("ticketId is null") return end
	if (strData) then Dbg("ReceivedAsync: " .. strData) end
	if (strError) then
		Dbg("[ReceivedAsync]: ERROR | " .. strError)
		if (ticket.errorHandler and type(ticket.errorHandler) == 'function') then
			ticket.errorHandler(strError)
		end
		return
	end

	ticket.handler(strData, tHeaders)
end

function urlGet(url, headers, callback, errorHandler)
	local ticketId = C4:urlGet(url, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlPost(url, data, headers, callback, errorHandler)
	local ticketId = C4:urlPost(url, data, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlPut(url, data, headers, callback, errorHandler)
	local ticketId = C4:urlPut(url, data, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlEncode(str)
	return str:gsub(" ","+"):gsub("\n","\r\n"):gsub("([^%w])",function(ch)
			return string.format("%%%02X",string.byte(ch))
		end)
end

function pullUrlTicket(ticketId)
	local ticket = g_responseTickets[ticketId]
	g_responseTickets[ticketId] = nil
	return ticket
end

-- Comandi LUA Actions
--Execute Command
function ExecuteCommand(sCommand, tParams)
    --Dbg("ExecuteCommand")
	-- Remove any spaces (trim the command)
	local trimmedCommand = string.gsub(sCommand, " ", "")
	-- if function exists then execute (non-stripped)
	if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
		EX_CMD[sCommand](tParams)
	-- elseif trimmed function exists then execute
	elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
		EX_CMD[trimmedCommand](tParams)
	-- handle the command
	elseif (EX_CMD[sCommand] ~= nil) then
		QueueCommand(EX_CMD[sCommand])
	else
		--Dbg:Alert("ExecuteCommand: Unhandled command = " .. sCommand)
	end
end

-- decode table tParams
function EX_CMD.LUA_ACTION(tParams)
	 --  print("dddd")
	if tParams ~= nil then
		for cmd,cmdv in pairs(tParams) do
			if cmd == "ACTION" then
				if (LUA_ACTION[cmdv] ~= nil) then
					LUA_ACTION[cmdv]()
				else
					Dbg("Undefined Action")
					Dbg("Key: " .. cmd .. " Value: " .. cmdv)
				end
			else
				Dbg("Undefined Command")
				Dbg("Key: " .. cmd .. " Value: " .. cmdv)
			end
		end
	end
end

--stampa messaggi se la properties Debug è su On
function Dbg (msg)
    if Properties[Debug] == "On" then
	   local data = os.date("%d/%m/%Y %X")
	   print (data.." - "..msg)
    end
end

